Тут, короче, что получилось
5 2 1 5 1 2 2 4 — допустим длины сегментов, s = 5
Мотивируясь тем, что если двигать окно с l = 0, r = l до n, то, например, кусок (4ка), имеющий иметь один надрез, будет использоваться постоянно — что не круто, ведь зачем каждый раз считать его, если, собственно, значение всегда будет известно.
Поэтому составим массив коэффициентов-популярностей для каждого числа, [0 0 0 0 0 0 0 0]
Берем 4ку, при ней 1 кусок, тогда массив выглядит так: [0 0 0 0 0 0 0 1]
Берем 2ку, при сложении с 4кой получается сумма больше s=5, поэтомук делаем вывод, что 2ка принадлежит другому куску. Итого кусок 2 4 имеет 1 надрез, а 4ка участвствует уже в качестве своего куска и в качестве куска в паре 2 и 4, поэтому, ей прибавим 1 и значение популярности будет равно 2: [0 0 0 0 0 0 1 2]
Берем еще 2ку, при сложении с 2 из своего (крайнего левого) куска, выхода за пределы s не происходит, значит, у нее популярность равна 1
Берем 1ку, при сложении с двумя 2ками получается 5, не превосходит, значит ей тоже пишем единичку: [0 0 0 0 0 1 1 2]
Берем 5ку, при сложении выходим за s, значит начинаем новый кусок, итого получаем 3 куска, и кусок 122 используется в себе и в отношениях с куском 5ки, а кусок 4ка используется в себе, в отношениях с 122 и в отношениях с 5кой. Значит, поставим коэф 1 для 5ки, а у остальных увеличим на 1ку: [0 0 0 1 2 2 2 3]

И так далее, получаем такую историю:

0 0 0 0 0 0 0 1 
0 0 0 0 0 0 1 2 
0 0 0 0 0 1 1 2 
0 0 0 0 1 1 1 2 
0 0 0 1 2 2 2 3 
0 0 1 2 3 3 3 4 
0 1 1 2 3 3 3 4 
1 2 2 3 4 4 4 5 

Фактически, нужно посчитать сумму всех чисел в матрице коэффициентов (истории)

Версия 2 кода учитывает эту реализацию. Первая же занимается реальным двиганием окна.
/*
int main() {
    size_t n;
    long long s;
    std::cin >> n >> s;
    // n = 7;
    // s = 5;

    std::vector<long long> a(n);
    for (size_t i = 0; i < n; ++i) {
        std::cin >> a[i];
    }
    // a[0] = 5;
    // a[1] = 1;
    // a[2] = 5;
    // a[3] = 1;
    // a[4] = 5;
    // a[5] = 1;
    // a[6] = 5;

    long long total = 0;
    for (size_t l = 0; l < n; ++l) {
        long long current_sum = 0;
        long long cuts = 0;

        for (size_t r = l; r < n; ++r) {
            current_sum += a[r];

            if (a[r] > s) {
                cuts = r - l + 1;
                total += cuts;
                break;
            }

            if (current_sum > s) {
                cuts++;
                current_sum = a[r];
            }

            total += cuts + 1;
        }
    }


    std::cout << total << std::endl;
    return 0;
}
*/
/*
int main() {
    size_t n;
    long long s;
    // std::cin >> n >> s;
    n = 25000;
    s = 5;

    std::vector<long long> a(n);
    for (size_t i = 0; i < n; ++i) {
        // std::cin >> a[i];
        if (i % 2 == 0) {
            a[i] = 5;
        } else {
            a[i] = 1;
        }
    }

    // a[0] = 5;
    // a[1] = 1;
    // a[2] = 5;
    // a[3] = 1;
    // a[4] = 2;
    // a[5] = 2;
    // a[6] = 4;
    std::vector<int> coefs(n, 0);
    long long total = 0;
    long long current_sum = 0;
    for (int i = n - 1; i >= 0; --i) {
        current_sum += a[i];
        if (current_sum > s) {
            for (int j = i; j < n; ++j) {
                coefs[j]++;
            }
            current_sum = a[i];
        } else {
            coefs[i]++;
        }
        for (int j = i; j < n; ++j) {
            total += coefs[j];
        }
        // for (int j = 0; j < n; ++j) {
        //     std::cout << coefs[j] << " ";
        // }
        // std::cout << ", total: " << total << std::endl;
    }
    std::cout << total << std::endl;
}
*/

Еще пример, который в задании
3 числа, s=3
1 2 3

Составим так таблицу

Для 3: [     0      0 f(3,3)] = 0 0 1
Для 2: [     0 f(2,2) f(2,3)] = 0 1 2
Для 1: [f(1,1) f(1,2) f(1,3)] = 1 1 2

Сумма всех значений = 8

Значит смысл в том, чтобы сосчитать сумму значений в матрице. А это нужно идти по строкам и столбцам, что при больших n недопустимо.

Приходит в голову мысль взглянуть на столбцы таблицы слева направо.
Видно, что если кусок заканчивается, то на этой строке к этому значению в следющем столбике добавляется 1, и в значении над этой строкой ставится 1
А если кусок продолжается, то просто активируется новое число, а остальные значения копируются.

Так появляется мысль, что можно не анализировать вектор коэффициентов, а просто заниматься добавлением единичек, основываясь на данных даже не всех предыдущих шагов, а всего лишь нескольких.
Пара часов размышлений и выведена рекуррентная формула total = total + prev + i + 1, для случая, когда кусок новый, где prev считается как total - total_pre, что означает всего лишь сумму чисел в предыдущем столбце, а total всех предыдущих столбцов, а total_pre значение, которое было в предыдущей итерации. Прикол в том, что к каждому значению в стобике приплюсовывается 1, что означает, что можно просто прибавить i+1, то бишь колличество обработанных значений в случае, когда новый кусок не появляется, а в случае, когда продолжается, сумма значений в столбце и вовсе меняется просто на 1. 
Таким образом, короче говоря, новая сумма равна предыдущей сумме, сумме в столбце, единички, и колличестве обработанных элементов.
Ахренеть задача упростилась и вообще отошла от плавающего окна :)